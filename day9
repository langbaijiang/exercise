1.将有序数组转换为二叉搜索树
根本思想是借助中序遍历的原理，再利用分治递归的思想，但这个边界有些难以理解，后续回顾时候重点看看。
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
    return fenzhi(nums,0,nums.size()-1);
    
    }

TreeNode* fenzhi(vector<int>& nums,int left,int right){
    if(left>right)return nullptr;
    int mid=(left+right)/2;
    TreeNode* root=new TreeNode(nums[mid]);
    root->left= fenzhi(nums,left,mid-1);
    root->right=fenzhi(nums,mid+1,right);
    return root;
}
};
2.位1的个数
中心思想：n&（n-1），每次会将n的最低位的1翻为0。位运算真妙啊，这也意味着大部分只能死记硬背，啧。
class Solution {
public:
    int hammingWeight(int n) {
        int count=0;
        while(n){
            n=n&(n-1);
            count++;
        }
        return count;
    }
};
3.只出现一次的数字
emmm，又学到一个新知识———^。a^b^a=a^a^b=b;a^0=a;a^a=0;
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result=0;
        for(auto c:nums)result=result^c;
        return result;
    }
};

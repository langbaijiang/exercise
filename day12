1.H指数
哈哈哈哈，被劳资超级无极笨方法做出来了，下面就是
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n=citations.size();
        for(int i=n-1;i>=0;i--){
            int result=0;
            for(auto c:citations){
                if(i+1<=c)result++;
            }
            if(result>=i+1)return i+1;
        }
    return 0;
    }
};
看看官方优解，嗯。。很扯，不看了。
2.除自身以外数组的乘积
DeepSeek给的答案，利用前缀乘后缀得到结果，边遍历边更新前后缀。
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, 1);
        
        // 计算前缀乘积（左到右）
        int prefix = 1;
        for (int i = 0; i < n; i++) {
            result[i] = prefix;
            prefix *= nums[i];
        }
        
        // 计算后缀乘积并直接相乘（右到左）
        int suffix = 1;
        for (int i = n-1; i >= 0; i--) {
            result[i] *= suffix;
            suffix *= nums[i];
        }
        
        return result;
    }
};
3.加油站
好难啊这题。这题用的贪心，关键点是——若从 start 出发到 i 时油量不足，则 start 到 i 之间的加油站均无法作为起点。因此直接跳过这些点，从 i+1 重新开始。
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n=gas.size();
        int total=0,current=0,start=0;
        int i=0;
        for(int i=0;i<n;i++){
            total=total+gas[i]-cost[i];
            current=current+gas[i]-cost[i];
            if(current<0){
                current=0;
                start=i+1;
            }
        }
        if(total<0)return -1;
        else return start;
    }
};
4.
